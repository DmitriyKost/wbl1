# Устные вопросы

### Какой самый эффективный способ конкатенации строк?
Лучшим способом будет использовать `strings.Builder`, или `bytes.Buffer`.

### Что такое интерфейсы, как они применяются в Go?
Интерфейс в Go - это набор методов, любой тип который реализует эти методы реализует интерфейс.

### Чем отличаются RWMutex от Mutex?
`Mutex` предоставляет доступ эксклюзивно одной горутине, `RWMutex` предоставляет доступ многим горутинам для чтения или одной для записи.

### Чем отличаются буферизированные и не буферизированные каналы?
Буферизованный канал позволяет отправителю отправлять данные без ожидания пока не заполниться буфер, небуферизованный будет блокировать отравителя пока, данные не будут прочитаны. 

### Какой размер у структуры struct{}{}?
Пустая структра имеет размер 0.

### Есть ли в Go перегрузка методов или операторов?
В Go нет перегрузки методов или операторов.

### В какой последовательности будут выведены элементы map[int]int?
Пример:
```go
m[0] = 1
m[1] = 124
m[2] = 281
```
В случайной. (Если пользоваться fmt.Println(map), то fmt отсортирует по ключам)

### В чем разница make и new?
`make` используется для создания slice, map или channel, `new` позволяет аллоцировать память под любой тип данных.
`make` возвращает объект, `new` - указатель на объект.

### Сколько существует способов задать переменную типа slice или map?
Четыре:
```go
var slice []int
slice := []int{}
slice := make([]int, 0)
slice := new([]int)

var myMap map[int]int
myMap := map[int]int{}
myMap := make(map[int]int)
myMap := new(map[int]int)
```

### Что выведет данная программа и почему?
```go
func update(p *int) {
  b := 2
  p = &b
}

func main() {
  var (
     a = 1
     p = &a
  )
  fmt.Println(*p)
  update(p)
  fmt.Println(*p)
}
```

Программа выведет:
```sh
1
1
```
В функцию update передается копия указателя `p`, поэтому при ее измении указатель в main продолжает указывать на `a`.
### Что выведет данная программа и почему?

```go
func main() {
  wg := sync.WaitGroup{}
  for i := 0; i < 5; i++ {
     wg.Add(1)
     go func(wg sync.WaitGroup, i int) {
        fmt.Println(i)
        wg.Done()
     }(wg, i)
  }
  wg.Wait()
  fmt.Println("exit")
}
```
Сначала программа выведет 4 0 1 2 3 ,из-за реализации локальной очереди в Go порядок будет таким:
Мы складываем в одноэлементный стэк 0 (LIFO), он вытесняется 1 в очередь FIFO, так идем до 4, 4 вытесняет 3
и застревает в стеке, поэтому выполняется первым.
Затем программа выдаст ошибку, потому что в горутины передается копия `WaitGroup`, а не
указатель на нее.

### Что выведет данная программа и почему?
```go
func main() {
  n := 0
  if true {
     n := 1
     n++
  }
  fmt.Println(n)
}
```
Программа выведет 0 т.к. переменная `n` внутри блока `if` имеет локакальную область видимости.

### Что выведет данная программа и почему?
```go
func someAction(v []int8, b int8) {
  v[0] = 100
  v = append(v, b)
}

func main() {
  var a = []int8{1, 2, 3, 4, 5} // capacity = 5
  someAction(a, 6)
  fmt.Println(a)
}
```

Программа выведет:
```sh
[100 2 3 4 5]
```

Потому что слайсы в Go - ссылочный тип данных (они указывают на определенный сегмент в памяти),
когда мы присваиваем 0-му элементу значение 100, мы изменяем этот сегмент.
Функция `append` создает новый слайс (если превышено значение capacity - текущая выделенная память под слайс), поэтому локальная переменная `v` внутри функции `someAction` просто начинает указывать на новый слайс, не изменяя старый.

### Что выведет данная программа и почему?
```go
func main() {
  slice := []string{"a", "a"} // capacity = 2

  func(slice []string) {
     slice = append(slice, "a")
     slice[0] = "b"
     slice[1] = "b"
     fmt.Print(slice)
  }(slice)
  fmt.Print(slice)
}
```
Программа выведет:
```sh 
[b b a]
[a a]
```
Слайсы в Go - ссылочные в анонимную функцию мы передаем копию указателя на наш `slice`, после вызова `append` указатель внутри функции указывает уже на новый слайс (т.к. превышено capacity - текущая выделенная под слайс память), и производит изменения только с ним.
